//
//  MyStyleKit.m
//  vBox
//
//  Created by Rosbel Sanroman on 12/15/14.
//  Copyright (c) 2014 Rosbel. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "MyStyleKit.h"


@implementation MyStyleKit

#pragma mark Cache

static UIColor* _myOrange = nil;
static UIColor* _mySkyBlue = nil;
static UIColor* _vitaminCColor = nil;
static UIColor* _route66Color = nil;
static UIColor* _steadyGreyColor = nil;
static UIColor* _bcColor = nil;
static UIColor* _gamebookersBlueColor = nil;

#pragma mark Initialization

+ (void)initialize
{
    // Colors Initialization
    _myOrange = [UIColor colorWithRed: 0.98 green: 0.412 blue: 0 alpha: 1];
    _mySkyBlue = [UIColor colorWithRed: 0.412 green: 0.824 blue: 0.906 alpha: 1];
    _vitaminCColor = [UIColor colorWithRed: 1 green: 0.6 blue: 0 alpha: 1];
    _route66Color = [UIColor colorWithRed: 0.259 green: 0.259 blue: 0.259 alpha: 1];
    _steadyGreyColor = [UIColor colorWithRed: 0.914 green: 0.914 blue: 0.914 alpha: 1];
    _bcColor = [UIColor colorWithRed: 0.737 green: 0.737 blue: 0.737 alpha: 1];
    _gamebookersBlueColor = [UIColor colorWithRed: 0.196 green: 0.6 blue: 0.733 alpha: 1];

}

#pragma mark Colors

+ (UIColor*)myOrange { return _myOrange; }
+ (UIColor*)mySkyBlue { return _mySkyBlue; }
+ (UIColor*)vitaminCColor { return _vitaminCColor; }
+ (UIColor*)route66Color { return _route66Color; }
+ (UIColor*)steadyGreyColor { return _steadyGreyColor; }
+ (UIColor*)bcColor { return _bcColor; }
+ (UIColor*)gamebookersBlueColor { return _gamebookersBlueColor; }

#pragma mark Drawing Methods

+ (void)drawVBoxButtonWithButtonColor: (UIColor*)buttonColor
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    CGFloat buttonColorRGBA[4];
    [buttonColor getRed: &buttonColorRGBA[0] green: &buttonColorRGBA[1] blue: &buttonColorRGBA[2] alpha: &buttonColorRGBA[3]];

    UIColor* buttonShadow = [UIColor colorWithRed: (buttonColorRGBA[0] * 0.6) green: (buttonColorRGBA[1] * 0.6) blue: (buttonColorRGBA[2] * 0.6) alpha: (buttonColorRGBA[3] * 0.6 + 0.4)];

    //// Shadow Declarations
    UIColor* shadow = buttonShadow;
    CGSize shadowOffset = CGSizeMake(0.1, 3.1);
    CGFloat shadowBlurRadius = 0;

    //// Group
    {
        CGContextSaveGState(context);
        CGContextSetShadowWithColor(context, shadowOffset, shadowBlurRadius, [shadow CGColor]);
        CGContextBeginTransparencyLayer(context, NULL);


        //// Rectangle Drawing
        UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(0, 0, 221, 30) cornerRadius: 5];
        [buttonColor setFill];
        [rectanglePath fill];


        CGContextEndTransparencyLayer(context);
        CGContextRestoreGState(context);
    }
}

+ (void)drawSpeedometerWithStrokeColor: (UIColor*)strokeColor
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Group
    {
        //// Oval Drawing
        UIBezierPath* ovalPath = UIBezierPath.bezierPath;
        [ovalPath moveToPoint: CGPointMake(49, 25.81)];
        [ovalPath addCurveToPoint: CGPointMake(42.91, 10.35) controlPoint1: CGPointMake(49, 19.84) controlPoint2: CGPointMake(46.69, 14.41)];
        [ovalPath moveToPoint: CGPointMake(31.81, 3.73)];
        [ovalPath addCurveToPoint: CGPointMake(26, 3) controlPoint1: CGPointMake(29.95, 3.25) controlPoint2: CGPointMake(28.01, 3)];
        [ovalPath addCurveToPoint: CGPointMake(3, 25.81) controlPoint1: CGPointMake(13.3, 3) controlPoint2: CGPointMake(3, 13.21)];
        ovalPath.lineCapStyle = kCGLineCapRound;

        [strokeColor setStroke];
        ovalPath.lineWidth = 4;
        [ovalPath stroke];


        //// Bezier 2 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 28.31, 18.24);
        CGContextRotateCTM(context, 10.82 * M_PI / 180);

        UIBezierPath* bezier2Path = UIBezierPath.bezierPath;
        [bezier2Path moveToPoint: CGPointMake(8.39, -13.04)];
        [bezier2Path addCurveToPoint: CGPointMake(2.41, 6.29) controlPoint1: CGPointMake(8.39, -13.04) controlPoint2: CGPointMake(2.71, 6.45)];
        [bezier2Path addCurveToPoint: CGPointMake(-1.54, 8.84) controlPoint1: CGPointMake(1.69, 7.8) controlPoint2: CGPointMake(0.19, 8.84)];
        [bezier2Path addCurveToPoint: CGPointMake(-5.95, 4.23) controlPoint1: CGPointMake(-3.97, 8.84) controlPoint2: CGPointMake(-5.95, 6.78)];
        [bezier2Path addCurveToPoint: CGPointMake(-5.48, 2.17) controlPoint1: CGPointMake(-5.95, 3.49) controlPoint2: CGPointMake(-5.78, 2.79)];
        [bezier2Path addCurveToPoint: CGPointMake(8.39, -13.04) controlPoint1: CGPointMake(-5.78, 2.02) controlPoint2: CGPointMake(8.39, -13.04)];
        [bezier2Path addLineToPoint: CGPointMake(8.39, -13.04)];
        [bezier2Path closePath];
        [strokeColor setFill];
        [bezier2Path fill];

        CGContextRestoreGState(context);
    }
}

+ (void)drawGaugeWithStrokeColor: (UIColor*)strokeColor value: (CGFloat)value maxValue: (CGFloat)maxValue label: (NSString*)label
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();


    //// Variable Declarations
    CGFloat boundedValue = value < 0 ? 0 : (value > maxValue ? maxValue : value);
    CGFloat angle = boundedValue * -1 * (180.0 / maxValue);

    //// Group
    {
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 5, 3);
        CGContextScaleCTM(context, 0.5, 0.5);



        //// gaugeBorder Drawing
        UIBezierPath* gaugeBorderPath = UIBezierPath.bezierPath;
        [gaugeBorderPath moveToPoint: CGPointMake(122, 61)];
        [gaugeBorderPath addCurveToPoint: CGPointMake(61, 0) controlPoint1: CGPointMake(122, 27.31) controlPoint2: CGPointMake(94.69, 0)];
        [gaugeBorderPath addCurveToPoint: CGPointMake(0, 61) controlPoint1: CGPointMake(27.31, -0) controlPoint2: CGPointMake(0, 27.31)];
        gaugeBorderPath.lineCapStyle = kCGLineCapRound;

        [strokeColor setStroke];
        gaugeBorderPath.lineWidth = 8;
        [gaugeBorderPath stroke];


        //// gaugePin Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 61.4, 60);
        CGContextRotateCTM(context, -angle * M_PI / 180);

        UIBezierPath* gaugePinPath = UIBezierPath.bezierPath;
        [gaugePinPath moveToPoint: CGPointMake(-40.99, -1.21)];
        [gaugePinPath addCurveToPoint: CGPointMake(-0.06, -8.96) controlPoint1: CGPointMake(-41, -1.21) controlPoint2: CGPointMake(-0.05, -9.64)];
        [gaugePinPath addCurveToPoint: CGPointMake(8.34, -4.28) controlPoint1: CGPointMake(3.39, -9.1) controlPoint2: CGPointMake(6.7, -7.4)];
        [gaugePinPath addCurveToPoint: CGPointMake(4.12, 8.1) controlPoint1: CGPointMake(10.65, 0.12) controlPoint2: CGPointMake(8.76, 5.66)];
        [gaugePinPath addCurveToPoint: CGPointMake(-0.08, 9.24) controlPoint1: CGPointMake(2.77, 8.81) controlPoint2: CGPointMake(1.34, 9.18)];
        [gaugePinPath addCurveToPoint: CGPointMake(-41, -1.21) controlPoint1: CGPointMake(-0.08, 9.92) controlPoint2: CGPointMake(-41, -1.21)];
        [gaugePinPath addLineToPoint: CGPointMake(-40.99, -1.21)];
        [gaugePinPath closePath];
        [strokeColor setFill];
        [gaugePinPath fill];

        CGContextRestoreGState(context);


        //// gaugeLabel Drawing
        CGRect gaugeLabelRect = CGRectMake(7, 69, 108, 21);
        NSMutableParagraphStyle* gaugeLabelStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
        gaugeLabelStyle.alignment = NSTextAlignmentCenter;

        NSDictionary* gaugeLabelFontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: UIFont.labelFontSize], NSForegroundColorAttributeName: UIColor.blackColor, NSParagraphStyleAttributeName: gaugeLabelStyle};

        CGFloat gaugeLabelTextHeight = [label boundingRectWithSize: CGSizeMake(gaugeLabelRect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: gaugeLabelFontAttributes context: nil].size.height;
        CGContextSaveGState(context);
        CGContextClipToRect(context, gaugeLabelRect);
        [label drawInRect: CGRectMake(CGRectGetMinX(gaugeLabelRect), CGRectGetMinY(gaugeLabelRect) + (CGRectGetHeight(gaugeLabelRect) - gaugeLabelTextHeight) / 2, CGRectGetWidth(gaugeLabelRect), gaugeLabelTextHeight) withAttributes: gaugeLabelFontAttributes];
        CGContextRestoreGState(context);



        CGContextRestoreGState(context);
    }
}

#pragma mark Generated Images

+ (UIImage*)imageOfVBoxButtonWithButtonColor: (UIColor*)buttonColor
{
    UIGraphicsBeginImageContextWithOptions(CGSizeMake(221, 33), NO, 0.0f);
    [MyStyleKit drawVBoxButtonWithButtonColor: buttonColor];

    UIImage* imageOfVBoxButton = [UIGraphicsGetImageFromCurrentImageContext() resizableImageWithCapInsets: UIEdgeInsetsMake(7, 17, 10, 19) resizingMode: UIImageResizingModeStretch];
    UIGraphicsEndImageContext();

    return imageOfVBoxButton;
}

+ (UIImage*)imageOfSpeedometerWithStrokeColor: (UIColor*)strokeColor
{
    UIGraphicsBeginImageContextWithOptions(CGSizeMake(52, 28), NO, 0.0f);
    [MyStyleKit drawSpeedometerWithStrokeColor: strokeColor];

    UIImage* imageOfSpeedometer = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();

    return imageOfSpeedometer;
}

@end
